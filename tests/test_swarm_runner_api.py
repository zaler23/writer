from __future__ import annotations

from fastapi.testclient import TestClient

from app.db import get_connection
from app.main import app


def _create_project_and_chapter(client: TestClient, name: str = "Runner Book") -> tuple[str, str]:
    project_resp = client.post("/projects", json={"name": name})
    assert project_resp.status_code == 200
    project_id = project_resp.json()["id"]

    chapter_resp = client.post(
        "/chapters",
        json={"project_id": project_id, "volume_no": 1, "chapter_no": 1, "title": "Chapter One"},
    )
    assert chapter_resp.status_code == 200
    chapter_id = chapter_resp.json()["id"]
    return project_id, chapter_id


def test_swarm_run_auto_start_completes_and_records_llm_call(monkeypatch, tmp_path) -> None:
    db_path = tmp_path / "core.db"
    monkeypatch.setenv("WRITER_DB_PATH", str(db_path))
    app.state.llm_generate = lambda request: {
        "content_text": "Generated by test LLM",
        "provider_id": "test-provider",
        "model_id": "test-model",
        "usage_json": {"prompt_tokens": 11, "completion_tokens": 22},
    }

    try:
        with TestClient(app) as client:
            project_id, chapter_id = _create_project_and_chapter(client)
            run_resp = client.post(
                "/swarm/run",
                json={
                    "project_id": project_id,
                    "chapter_id": chapter_id,
                    "input_json": {"prompt": "Write opening scene"},
                },
            )
            assert run_resp.status_code == 200
            run = run_resp.json()
            assert run["status"] == "completed"

            run_id = run["id"]
            steps_resp = client.get(f"/runs/{run_id}/steps")
            assert steps_resp.status_code == 200
            steps = steps_resp.json()["items"]
            assert len(steps) == 1
            assert steps[0]["status"] == "completed"

            chapter_resp = client.get(f"/chapters/{chapter_id}")
            assert chapter_resp.status_code == 200
            assert chapter_resp.json()["status"] == "finalized"

            versions_resp = client.get(f"/chapters/{chapter_id}/text-versions")
            assert versions_resp.status_code == 200
            versions = versions_resp.json()["items"]
            assert len(versions) == 1
            assert versions[0]["stage"] == "final"
            assert versions[0]["content_text"] == "Generated by test LLM"

            with get_connection() as conn:
                llm_call = conn.execute(
                    "SELECT run_id, status, request_hash, response_hash, usage_json "
                    "FROM llm_calls WHERE run_id = ?",
                    (run_id,),
                ).fetchone()
            assert llm_call is not None
            assert llm_call["status"] == "succeeded"
            assert llm_call["request_hash"]
            assert llm_call["response_hash"]
            assert llm_call["usage_json"]
    finally:
        if hasattr(app.state, "llm_generate"):
            delattr(app.state, "llm_generate")


def test_swarm_run_pause_for_approval_then_approve(monkeypatch, tmp_path) -> None:
    db_path = tmp_path / "core.db"
    monkeypatch.setenv("WRITER_DB_PATH", str(db_path))
    app.state.llm_generate = lambda request: {"content_text": "Needs human approval"}

    try:
        with TestClient(app) as client:
            project_id, chapter_id = _create_project_and_chapter(client, "Approval Book")
            run_resp = client.post(
                "/swarm/run",
                json={"project_id": project_id, "chapter_id": chapter_id, "requires_approval": True},
            )
            assert run_resp.status_code == 200
            run = run_resp.json()
            assert run["status"] == "paused"
            run_id = run["id"]

            step_resp = client.get(f"/runs/{run_id}/steps")
            assert step_resp.status_code == 200
            step = step_resp.json()["items"][0]
            assert step["status"] == "pending_approval"

            approved = client.post(f"/runs/{run_id}/steps/{step['id']}/approve")
            assert approved.status_code == 200
            assert approved.json()["status"] == "completed"

            run_after = client.get(f"/runs/{run_id}")
            assert run_after.status_code == 200
            assert run_after.json()["status"] == "completed"

            chapter_resp = client.get(f"/chapters/{chapter_id}")
            assert chapter_resp.status_code == 200
            assert chapter_resp.json()["status"] == "finalized"
    finally:
        if hasattr(app.state, "llm_generate"):
            delattr(app.state, "llm_generate")


def test_swarm_run_override_approval_output(monkeypatch, tmp_path) -> None:
    db_path = tmp_path / "core.db"
    monkeypatch.setenv("WRITER_DB_PATH", str(db_path))
    app.state.llm_generate = lambda request: {"content_text": "Original LLM output"}

    try:
        with TestClient(app) as client:
            project_id, chapter_id = _create_project_and_chapter(client, "Override Book")
            run_resp = client.post(
                "/swarm/run",
                json={"project_id": project_id, "chapter_id": chapter_id, "requires_approval": True},
            )
            run_id = run_resp.json()["id"]
            step_id = client.get(f"/runs/{run_id}/steps").json()["items"][0]["id"]

            override_resp = client.post(
                f"/runs/{run_id}/steps/{step_id}/override",
                json={"content_text": "Human override text"},
            )
            assert override_resp.status_code == 200
            assert override_resp.json()["status"] == "completed"
            assert override_resp.json()["override_payload_json"]["content_text"] == "Human override text"

            versions_resp = client.get(f"/chapters/{chapter_id}/text-versions")
            assert versions_resp.status_code == 200
            assert versions_resp.json()["items"][0]["content_text"] == "Human override text"
    finally:
        if hasattr(app.state, "llm_generate"):
            delattr(app.state, "llm_generate")


def test_swarm_run_resume_from_created_and_cancel(monkeypatch, tmp_path) -> None:
    db_path = tmp_path / "core.db"
    monkeypatch.setenv("WRITER_DB_PATH", str(db_path))
    app.state.llm_generate = lambda request: {"content_text": "Resume flow output"}

    try:
        with TestClient(app) as client:
            project_id, chapter_id = _create_project_and_chapter(client, "Resume Book")
            created = client.post(
                "/swarm/run",
                json={"project_id": project_id, "chapter_id": chapter_id, "auto_start": False},
            )
            assert created.status_code == 200
            run_id = created.json()["id"]
            assert created.json()["status"] == "created"

            resumed = client.post(f"/runs/{run_id}/resume")
            assert resumed.status_code == 200
            assert resumed.json()["status"] == "completed"

            project_id_2, chapter_id_2 = _create_project_and_chapter(client, "Cancel Book")
            created_2 = client.post(
                "/swarm/run",
                json={"project_id": project_id_2, "chapter_id": chapter_id_2, "auto_start": False},
            )
            run_id_2 = created_2.json()["id"]
            cancelled = client.post(f"/runs/{run_id_2}/cancel")
            assert cancelled.status_code == 200
            assert cancelled.json()["status"] == "cancelled"
    finally:
        if hasattr(app.state, "llm_generate"):
            delattr(app.state, "llm_generate")
